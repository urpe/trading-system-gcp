# V22.1 "DATA INTEGRITY CORE" - DESIGN DOCUMENT

**VersiÃ³n:** V22.1  
**Fecha DiseÃ±o:** 2026-02-08  
**Arquitecto:** HFT Trading Bot Team  
**Status:** ðŸ“‹ DESIGN (No implementado)  
**Fundamento:** V21.3 Canonical Core (TradingSymbol Value Object)

---

## ðŸŽ¯ OBJETIVO

**Cerrar la "Grieta de Persistencia":** Hacer que la base de datos SQLite hable el mismo idioma que el cÃ³digo Python (TradingSymbol Value Object).

### **Problema Actual (V21.3):**
```python
# CÃ“DIGO (Python) - Type-safe
symbol = TradingSymbol.from_str("BTC")  # âœ… Value Object

# BASE DE DATOS (SQLite) - String-based
class Trade(Base):
    symbol = Column(String, nullable=False)  # âŒ Plain string

# CONVERSIÃ“N MANUAL (error-prone)
trade = Trade(symbol=symbol.to_short())  # Developer must remember
```

### **SoluciÃ³n V22.1:**
```python
# CÃ“DIGO (Python) - Type-safe
symbol = TradingSymbol.from_str("BTC")  # âœ… Value Object

# BASE DE DATOS (SQLite) - Type-safe
class Trade(Base):
    symbol = Column(TradingSymbolType, nullable=False)  # âœ… Custom Type

# CONVERSIÃ“N AUTOMÃTICA (built-in)
trade = Trade(symbol=symbol)  # SQLAlchemy handles conversion
session.add(trade)
session.commit()  # Stored as JSON: {"base": "BTC", "quote": "USDT"}
```

---

## ðŸ“ ARQUITECTURA

### **1. SQLAlchemy Custom Type (Core)**

**Archivo:** `src/shared/database_types.py` (NUEVO)

```python
from sqlalchemy.types import TypeDecorator, String
from sqlalchemy import JSON
from src.domain import TradingSymbol, QuoteCurrency
import json

class TradingSymbolType(TypeDecorator):
    """
    SQLAlchemy custom type para TradingSymbol Value Object.
    
    ImplementaciÃ³n:
        - Almacena como JSON string en SQLite: '{"base": "BTC", "quote": "USDT"}'
        - Deserializa automÃ¡ticamente a TradingSymbol al leer
        - Serializa automÃ¡ticamente desde TradingSymbol al escribir
    
    Ventajas:
        - Type safety en queries
        - No mÃ¡s conversiones manuales
        - Soporte para Multi-Quote nativo
    
    Ejemplo:
        # Write
        symbol = TradingSymbol.from_str("ETHBTC")
        trade = Trade(symbol=symbol)  # Automatic serialization
        
        # Read
        trade = session.query(Trade).first()
        print(trade.symbol.to_long())  # Automatic deserialization
    """
    
    impl = String(100)  # Max 100 chars para JSON
    cache_ok = True     # Enable SQLAlchemy caching
    
    def process_bind_param(self, value, dialect):
        """
        Serialize TradingSymbol â†’ JSON string (for INSERT/UPDATE).
        
        Args:
            value: TradingSymbol instance or None
            dialect: SQLAlchemy dialect (sqlite, postgresql, etc.)
        
        Returns:
            JSON string: '{"base": "BTC", "quote": "USDT"}'
        
        Raises:
            TypeError: If value is not TradingSymbol or None
        """
        if value is None:
            return None
        
        if not isinstance(value, TradingSymbol):
            raise TypeError(
                f"Expected TradingSymbol, got {type(value).__name__}. "
                f"Value: {value}"
            )
        
        # Serialize to JSON
        data = {
            'base': value.base,
            'quote': value.quote.value
        }
        
        return json.dumps(data)
    
    def process_result_value(self, value, dialect):
        """
        Deserialize JSON string â†’ TradingSymbol (for SELECT).
        
        Args:
            value: JSON string from database or None
            dialect: SQLAlchemy dialect
        
        Returns:
            TradingSymbol instance or None
        
        Raises:
            ValueError: If JSON is invalid or missing required keys
        """
        if value is None:
            return None
        
        try:
            data = json.loads(value)
            
            # Validate structure
            if 'base' not in data or 'quote' not in data:
                raise ValueError(f"Invalid TradingSymbol JSON: {data}")
            
            # Reconstruct TradingSymbol
            return TradingSymbol(
                base=data['base'],
                quote=QuoteCurrency(data['quote'])
            )
        
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON in database: {value}") from e
        except (KeyError, ValueError) as e:
            raise ValueError(f"Could not deserialize TradingSymbol: {value}") from e


# ==========================================
# OPTIONAL: Alternative Implementation (Composite Columns)
# ==========================================

class TradingSymbolComposite(TypeDecorator):
    """
    Alternative: Store as two separate columns (base, quote).
    
    Pros:
        - Easier to query by base/quote separately
        - More efficient indexing
    
    Cons:
        - Requires ALTER TABLE (add new columns)
        - More complex migration
    
    Usage:
        class Trade(Base):
            symbol_base = Column(String(10), nullable=False)
            symbol_quote = Column(String(10), nullable=False)
            
            @hybrid_property
            def symbol(self):
                return TradingSymbol(
                    base=self.symbol_base,
                    quote=QuoteCurrency(self.symbol_quote)
                )
    """
    pass  # Implement if JSON approach has performance issues
```

---

### **2. Database Models Migration**

**Archivo:** `src/shared/database.py` (MODIFICAR)

#### **BEFORE (V21.3):**
```python
from sqlalchemy import Column, Integer, String, Float, DateTime

class Trade(Base):
    __tablename__ = 'trades'
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String, nullable=False, index=True)  # âŒ String
    side = Column(String, nullable=False)
    entry_price = Column(Float, nullable=False)
    # ...
```

#### **AFTER (V22.1):**
```python
from sqlalchemy import Column, Integer, String, Float, DateTime
from src.shared.database_types import TradingSymbolType  # NEW

class Trade(Base):
    __tablename__ = 'trades'
    
    id = Column(Integer, primary_key=True)
    symbol = Column(TradingSymbolType, nullable=False, index=True)  # âœ… Custom Type
    side = Column(String, nullable=False)
    entry_price = Column(Float, nullable=False)
    # ...
```

---

### **3. Data Migration Script**

**Archivo:** `migrate_db_to_v22.1.py` (NUEVO)

```python
#!/usr/bin/env python3
"""
Database Migration: V21.3 â†’ V22.1
==================================
Converts Trade.symbol from String to TradingSymbolType.

Steps:
1. Backup database
2. Read all trades (strings)
3. Convert to TradingSymbol
4. Write back as JSON
5. Verify integrity
"""

from src.shared.database import SessionLocal, Trade
from src.domain import TradingSymbol
import shutil
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("DBMigration")

def backup_database():
    """Create backup of database."""
    db_path = "src/data/trading_bot_v16.db"
    backup_path = f"src/data/trading_bot_v16_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
    
    logger.info(f"Creating backup: {backup_path}")
    shutil.copy2(db_path, backup_path)
    logger.info("âœ… Backup created")
    
    return backup_path

def migrate_trades():
    """Migrate Trade.symbol from String to TradingSymbolType."""
    session = SessionLocal()
    
    try:
        # Get all trades
        trades = session.query(Trade).all()
        logger.info(f"Found {len(trades)} trades to migrate")
        
        migrated = 0
        errors = 0
        
        for trade in trades:
            try:
                # Current value is string (e.g., "BTC", "BTCUSDT")
                current_symbol = trade.symbol
                
                # Convert to TradingSymbol
                symbol_obj = TradingSymbol.from_str(current_symbol)
                
                # Assign back (SQLAlchemy will serialize to JSON automatically)
                trade.symbol = symbol_obj
                
                migrated += 1
                
                if migrated % 100 == 0:
                    logger.info(f"Migrated {migrated} trades...")
            
            except Exception as e:
                logger.error(f"Error migrating trade {trade.id} (symbol={trade.symbol}): {e}")
                errors += 1
        
        # Commit changes
        session.commit()
        logger.info(f"âœ… Migration complete: {migrated} migrated, {errors} errors")
        
        return migrated, errors
    
    except Exception as e:
        logger.error(f"Fatal error during migration: {e}")
        session.rollback()
        raise
    
    finally:
        session.close()

def verify_migration():
    """Verify that migration was successful."""
    session = SessionLocal()
    
    try:
        trades = session.query(Trade).all()
        logger.info(f"Verifying {len(trades)} trades...")
        
        valid = 0
        invalid = 0
        
        for trade in trades:
            try:
                # Try to access TradingSymbol methods
                assert isinstance(trade.symbol, TradingSymbol)
                _ = trade.symbol.to_short()
                _ = trade.symbol.to_long()
                valid += 1
            except Exception as e:
                logger.error(f"Verification failed for trade {trade.id}: {e}")
                invalid += 1
        
        logger.info(f"âœ… Verification: {valid} valid, {invalid} invalid")
        
        return valid, invalid
    
    finally:
        session.close()

def main():
    logger.info("=" * 80)
    logger.info("DATABASE MIGRATION: V21.3 â†’ V22.1")
    logger.info("=" * 80)
    
    # Step 1: Backup
    backup_path = backup_database()
    
    # Step 2: Migrate
    migrated, errors = migrate_trades()
    
    # Step 3: Verify
    valid, invalid = verify_migration()
    
    # Summary
    logger.info("=" * 80)
    logger.info("MIGRATION SUMMARY")
    logger.info("=" * 80)
    logger.info(f"Backup: {backup_path}")
    logger.info(f"Migrated: {migrated}")
    logger.info(f"Errors: {errors}")
    logger.info(f"Verified: {valid}")
    logger.info(f"Invalid: {invalid}")
    
    if errors == 0 and invalid == 0:
        logger.info("âœ… Migration successful!")
    else:
        logger.warning("âš ï¸ Migration completed with errors. Review logs.")

if __name__ == '__main__':
    main()
```

---

### **4. Multi-Quote Support (Parser Enhancement)**

**Archivo:** `src/domain/trading_symbol.py` (MODIFICAR)

#### **Enhancement: Smart Quote Detection**

```python
class QuoteCurrency(Enum):
    USDT = "USDT"
    BTC = "BTC"     # NEW
    ETH = "ETH"     # NEW
    BUSD = "BUSD"   # NEW
    USDC = "USDC"   # NEW
    
    @classmethod
    def detect_from_pair(cls, pair: str) -> 'QuoteCurrency':
        """
        Auto-detect quote currency from pair string.
        
        Examples:
            "ETHBTC" â†’ BTC
            "BTCUSDT" â†’ USDT
            "SOLETH" â†’ ETH
        
        Algorithm:
            1. Try longest suffixes first (USDT, BUSD, USDC)
            2. Then 3-char (BTC, ETH, SOL)
            3. Default to USDT if not found
        """
        pair_upper = pair.upper()
        
        # Sort by length (longest first) to avoid false matches
        for quote in sorted(cls, key=lambda x: len(x.value), reverse=True):
            if pair_upper.endswith(quote.value):
                return quote
        
        return cls.USDT  # Default

@classmethod
def from_str(cls, symbol: str, default_quote: QuoteCurrency = None) -> 'TradingSymbol':
    """
    V22.1: Enhanced parser with auto-detection.
    
    Examples:
        "BTC" â†’ TradingSymbol(base="BTC", quote=USDT)
        "BTCUSDT" â†’ TradingSymbol(base="BTC", quote=USDT)
        "ETHBTC" â†’ TradingSymbol(base="ETH", quote=BTC)  # NEW
        "SOLETH" â†’ TradingSymbol(base="SOL", quote=ETH)  # NEW
    """
    if not isinstance(symbol, str):
        raise TypeError(f"Symbol must be str, got {type(symbol)}")
    
    symbol = symbol.strip().upper()
    
    if not symbol:
        raise ValueError("Symbol cannot be empty")
    
    # Auto-detect quote currency
    detected_quote = QuoteCurrency.detect_from_pair(symbol)
    
    # If suffix matches a quote, extract base
    if symbol.endswith(detected_quote.value):
        base = symbol[:-len(detected_quote.value)]
        
        # Validate base is not empty
        if not base:
            raise ValueError(f"Invalid symbol: {symbol} (empty base)")
        
        return cls(base=base, quote=detected_quote)
    
    # No suffix match â†’ assume it's already short format
    return cls(base=symbol, quote=default_quote or QuoteCurrency.USDT)
```

---

## ðŸ§ª TESTING STRATEGY

### **1. Unit Tests**

**Archivo:** `test_trading_symbol_type.py` (NUEVO)

```python
import pytest
from src.shared.database_types import TradingSymbolType
from src.domain import TradingSymbol, QuoteCurrency

def test_serialize_btcusdt():
    """Test serialization of BTC/USDT."""
    symbol = TradingSymbol.from_str("BTC")
    type_handler = TradingSymbolType()
    
    json_str = type_handler.process_bind_param(symbol, None)
    
    assert json_str == '{"base": "BTC", "quote": "USDT"}'

def test_deserialize_btcusdt():
    """Test deserialization of BTC/USDT."""
    json_str = '{"base": "BTC", "quote": "USDT"}'
    type_handler = TradingSymbolType()
    
    symbol = type_handler.process_result_value(json_str, None)
    
    assert isinstance(symbol, TradingSymbol)
    assert symbol.to_short() == "BTC"
    assert symbol.quote == QuoteCurrency.USDT

def test_serialize_ethbtc():
    """Test serialization of ETH/BTC (multi-quote)."""
    symbol = TradingSymbol.from_str("ETHBTC")
    type_handler = TradingSymbolType()
    
    json_str = type_handler.process_bind_param(symbol, None)
    
    assert json_str == '{"base": "ETH", "quote": "BTC"}'

def test_roundtrip():
    """Test serialize â†’ deserialize roundtrip."""
    original = TradingSymbol.from_str("SOLETH")
    type_handler = TradingSymbolType()
    
    # Serialize
    json_str = type_handler.process_bind_param(original, None)
    
    # Deserialize
    restored = type_handler.process_result_value(json_str, None)
    
    assert restored == original
    assert restored.to_long() == original.to_long()

def test_none_handling():
    """Test that None is handled correctly."""
    type_handler = TradingSymbolType()
    
    # Serialize None
    assert type_handler.process_bind_param(None, None) is None
    
    # Deserialize None
    assert type_handler.process_result_value(None, None) is None

def test_invalid_type_raises():
    """Test that invalid types raise TypeError."""
    type_handler = TradingSymbolType()
    
    with pytest.raises(TypeError):
        type_handler.process_bind_param("BTC", None)  # Should be TradingSymbol, not str
```

---

### **2. Integration Tests**

**Archivo:** `test_sqlalchemy_integration.py` (NUEVO)

```python
from src.shared.database import SessionLocal, Trade
from src.domain import TradingSymbol, QuoteCurrency
from datetime import datetime

def test_insert_and_query():
    """Test inserting and querying TradingSymbol."""
    session = SessionLocal()
    
    try:
        # Insert trade with TradingSymbol
        symbol = TradingSymbol.from_str("ETHBTC")
        trade = Trade(
            symbol=symbol,
            side="BUY",
            entry_price=0.065,
            amount=10.0,
            timestamp=datetime.utcnow()
        )
        
        session.add(trade)
        session.commit()
        
        # Query back
        retrieved = session.query(Trade).filter(
            Trade.symbol == symbol  # Type-safe comparison
        ).first()
        
        assert retrieved is not None
        assert isinstance(retrieved.symbol, TradingSymbol)
        assert retrieved.symbol.to_long() == "ETHBTC"
        assert retrieved.symbol.quote == QuoteCurrency.BTC
    
    finally:
        session.close()

def test_query_by_base():
    """Test querying by base currency (requires custom filter)."""
    # NOTE: This requires a custom comparator or expression
    # For V22.1, we can query by full symbol, or use raw SQL
    pass
```

---

## ðŸ“Š PERFORMANCE CONSIDERATIONS

### **Benchmarks (Expected)**

| **Operation** | **V21.3 (String)** | **V22.1 (Custom Type)** | **Overhead** |
|---------------|-------------------|-------------------------|--------------|
| Insert (1 trade) | 5ms | 6ms | +20% |
| Query (1 trade) | 3ms | 4ms | +33% |
| Bulk insert (1000) | 500ms | 600ms | +20% |
| Bulk query (1000) | 300ms | 400ms | +33% |

**AnÃ¡lisis:**
- Overhead es aceptable (~20-33%)
- Beneficios superan costos:
  - Type safety
  - No conversiones manuales
  - Multi-quote nativo

---

## ðŸš¨ RISKS & MITIGATION

### **Risk 1: Migration Downtime**
**Problem:** DB schema change requiere downtime.

**Mitigation:**
- Blue-Green deployment: mantener V21.3 mientras migra
- Migration script con rollback automÃ¡tico si falla

---

### **Risk 2: JSON Size**
**Problem:** JSON strings son mÃ¡s grandes que "BTC".

**Mitigation:**
- Max 100 chars (sobra espacio)
- Si es problema, usar columnas compuestas (base, quote)

---

### **Risk 3: Query Performance**
**Problem:** JSON no es indexable como strings simples.

**Mitigation:**
- SQLite 3.38+ soporta JSON functions
- Si necesario, aÃ±adir columna `symbol_base` con index

---

## âœ… SUCCESS CRITERIA

V22.1 serÃ¡ exitosa cuando:

1. âœ… `TradingSymbolType` funciona (unit tests pass)
2. âœ… Migration script convierte 100% de trades sin errors
3. âœ… Queries type-safe funcionan: `session.query(Trade).filter(Trade.symbol == symbol)`
4. âœ… Multi-quote pairs funcionan: ETHBTC, SOLETH, BTCBUSD
5. âœ… Performance overhead < 50%
6. âœ… Zero data corruption en migration
7. âœ… Backward compatibility: V21.3 puede leer DB (si necesario)

---

## ðŸ›£ï¸ IMPLEMENTATION ROADMAP

### **Phase 1: Prototype (1 dÃ­a)**
- Crear `database_types.py`
- Unit tests para serialization/deserialization
- Sandbox testing (no tocar DB real)

### **Phase 2: Migration Script (0.5 dÃ­as)**
- Crear `migrate_db_to_v22.1.py`
- Test en DB copia
- Verify rollback funciona

### **Phase 3: Multi-Quote Enhancement (0.5 dÃ­as)**
- Extender `QuoteCurrency` Enum
- Smart parser con auto-detecciÃ³n
- Unit tests

### **Phase 4: Integration (1 dÃ­a)**
- Actualizar `database.py` models
- Integration tests
- Performance benchmarks

### **Phase 5: Deployment (1 dÃ­a)**
- Deploy en local (test)
- Run migration
- Verify integrity
- Deploy a GCP VM (si exitoso)

---

## ðŸ“ NEXT STEPS

1. **Review este diseÃ±o** (valida que arquitectura es correcta)
2. **Aprobar roadmap** (Â¿proceder con implementaciÃ³n?)
3. **Prototipo en sandbox** (no tocar DB real hasta aprobar)
4. **Testing exhaustivo** (unit + integration + performance)
5. **Deploy gradual** (local â†’ GCP VM)

---

**Status:** ðŸ“‹ **AWAITING APPROVAL**

Una vez aprobado, proceder con implementaciÃ³n siguiendo este diseÃ±o.

---

**Documento generado:** 2026-02-08  
**Autor:** HFT Trading Bot Team  
**VersiÃ³n:** V22.1 Design Draft
